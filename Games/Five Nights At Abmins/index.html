<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Horror - Advanced Surveillance Suite v8.5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        canvas { display: block; }
        
        /* Core UI Elements */
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border: 2px solid #1a1a1a;
            cursor: pointer;
            z-index: 100;
            min-width: 350px;
            box-shadow: 0 0 50px rgba(0,0,0,1);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: rgba(255,255,255,0.4);
            border: 1px solid rgba(0,0,0,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #hud {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #0f0;
            font-size: 10px;
            pointer-events: none;
            text-shadow: 2px 2px 4px black;
            opacity: 0.7;
            letter-spacing: 1px;
        }

        /* Battery and Usage Meter */
        #battery-ui {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            text-align: right;
            pointer-events: none;
            z-index: 50;
        }
        #battery-pct { font-size: 32px; font-weight: bold; margin-bottom: 2px; text-shadow: 2px 2px 4px black; }
        .usage-container { display: flex; align-items: center; gap: 4px; justify-content: flex-end; opacity: 0.8; }
        .usage-bar { width: 10px; height: 16px; background: #111; border: 1px solid #333; }
        .usage-bar.active { background: #0f0; border-color: #0f0; box-shadow: 0 0 8px #0f0; }

        /* Equipment Hotbar */
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px;
            border: 1px solid #222;
            border-radius: 4px;
            pointer-events: none;
            z-index: 50;
        }
        .hotbar-slot {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: border-color 0.2s, box-shadow 0.2s;
            overflow: hidden;
        }
        .hotbar-slot.selected {
            border-color: #0f0;
            box-shadow: inset 0 0 8px rgba(0, 255, 0, 0.2);
            background: rgba(0, 255, 0, 0.03);
        }
        .item-label {
            position: absolute;
            bottom: 2px;
            font-size: 6px;
            color: #0f0;
            text-transform: uppercase;
        }

        /* Interaction Feedback */
        #interaction-msg {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            background: rgba(0,0,0,0.8);
            padding: 8px 24px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.2s, bottom 0.2s;
            pointer-events: none;
            border-left: 3px solid #0f0;
            white-space: nowrap;
            z-index: 60;
        }
        
        /* Advanced Camera Interface */
        #camera-ui {
            display: none;
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 200;
        }
        #camera-overlay {
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
            pointer-events: none;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.8);
        }
        #camera-noise {
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            opacity: 0.12;
            pointer-events: none;
            animation: noiseMove 0.2s steps(4) infinite;
        }
        @keyframes noiseMove { 0% { transform: translate(0,0); } 100% { transform: translate(2px,2px); } }

        #camera-flicker {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.02);
            opacity: 0;
            pointer-events: none;
            animation: flicker 4s linear infinite;
        }
        @keyframes flicker {
            0% { opacity: 0; }
            10% { opacity: 0.05; }
            11% { opacity: 0; }
            30% { opacity: 0; }
            31% { opacity: 0.08; }
            32% { opacity: 0; }
            100% { opacity: 0; }
        }

        #camera-label {
            position: absolute;
            top: 40px;
            left: 40px;
            color: #0f0;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px #000;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .recording-dot {
            width: 15px;
            height: 15px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }

        #exit-cams-btn {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(60, 0, 0, 0.85);
            color: #fff;
            border: 2px solid #f00;
            padding: 12px 50px;
            cursor: pointer;
            pointer-events: auto;
            text-transform: uppercase;
            font-weight: black;
            font-size: 16px;
            letter-spacing: 5px;
            transition: all 0.2s;
            backdrop-filter: blur(8px);
        }
        #exit-cams-btn:hover { background: #f00; box-shadow: 0 0 25px #f00; transform: translateX(-50%) scale(1.05); }

        /* Game State Overlays */
        #power-outage, #jumpscare {
            display: none;
            position: fixed;
            inset: 0;
            background: black;
            z-index: 1000;
            color: #400;
            font-family: 'Courier New', Courier, monospace;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        #jumpscare { background: #000; color: #f00; z-index: 2000; }

        .loading-bar-container {
            width: 100%;
            height: 2px;
            background: #111;
            margin-top: 20px;
            overflow: hidden;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: #00ff00;
            transition: width 0.1s;
        }
        
        #controls-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }
        .ui-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            color: #666;
            padding: 6px 12px;
            font-size: 9px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ui-btn:hover { border-color: #0f0; color: #0f0; background: rgba(0,255,0,0.05); }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="interaction-msg">SYSTEM INTERACTED</div>

    <div id="camera-ui">
        <div id="camera-noise"></div>
        <div id="camera-flicker"></div>
        <div id="camera-overlay"></div>
        <div id="camera-label">
            <div class="recording-dot"></div>
            <span>CAM 01 - MAIN HALL</span>
        </div>
        <button id="exit-cams-btn">DISCONNECT FEED [X]</button>
    </div>

    <div id="power-outage">
        <div>
            <h1 class="text-4xl font-bold mb-4">CRITICAL POWER FAILURE</h1>
            <p class="animate-pulse mb-8">ALL SECURITY SEALS DISENGAGED</p>
            <button id="reset-outage-btn" class="ui-btn border-[#0f0] text-[#0f0]">REBOOT CORE</button>
        </div>
    </div>

    <div id="jumpscare">
        <div>
            <h1 class="text-6xl font-black mb-4 italic">YOU ARE NOT ALONE</h1>
            <p class="animate-ping">CONNECTION TERMINATED</p>
            <button id="reset-jumpscare-btn" class="mt-12 ui-btn border-[#f00] text-[#f00] hover:bg-[#200]">RETRY SHIFT</button>
        </div>
    </div>

    <div id="overlay">
        <div id="status-text">
            <h1 class="text-2xl font-black mb-1 tracking-tighter">FAZBEAR ENTERTAINMENT</h1>
            <p class="text-[10px] text-gray-500 uppercase tracking-[0.3em] mb-4">Remote Access & Surveillance Initialized</p>
            <p id="loading-subtext" class="text-xs text-gray-400">Constructing Spatial Maps & AI Logic...</p>
        </div>
        <div class="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>

    <div id="hud">
        PHYSICAL_CORE: v8.5 // LOC: <span id="pos-display">0.0, 0.0, 0.0</span>
    </div>

    <div id="hotbar">
        <div class="hotbar-slot selected" data-slot="0"></div>
        <div class="hotbar-slot" data-slot="1"></div>
        <div class="hotbar-slot" data-slot="2"></div>
        <div class="hotbar-slot" data-slot="3"></div>
        <div class="hotbar-slot" data-slot="4"></div>
    </div>

    <div id="battery-ui">
        <div id="battery-pct">100%</div>
        <div class="usage-container" id="usage-bars">
            <span class="text-[10px] uppercase mr-2">Usage:</span>
            <div class="usage-bar"></div>
            <div class="usage-bar"></div>
            <div class="usage-bar"></div>
            <div class="usage-bar"></div>
            <div class="usage-bar"></div>
        </div>
    </div>

    <div id="controls-ui">
        <button id="copy-pos" class="ui-btn">Log Current Coordinates</button>
    </div>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.170.0';
        import { GLTFLoader } from 'https://esm.sh/three@0.170.0/examples/jsm/loaders/GLTFLoader.js';
        import { Octree } from 'https://esm.sh/three@0.170.0/examples/jsm/math/Octree.js';
        import { Capsule } from 'https://esm.sh/three@0.170.0/examples/jsm/math/Capsule.js';

        /**
         * Nexus Horror Engine - Advanced Surveillance and Physics Systems
         * Optimized for high-fidelity lighting and complex collision meshes.
         * v8.5: Refined camera look-vectors and lighting.
         */
        class Engine {
            constructor() {
                // Initial Scene Setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x010101);

                // Perspective Camera for First Person View
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.rotation.order = 'YXZ';

                // WebGL Renderer Configuration
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                // Core System States
                this.battery = 100.0;
                this.isPowerOut = false;
                this.isLoaded = false;
                this.activeSlot = 0;
                this.isGameOver = false;
                this.inCams = false;
                this.camBatteryTimer = 0;
               
                this.hasFlashlight = false;
                this.flashlightActive = false;
                this.flashlightBeam = null;
                this.flashlightWorldModel = null;

                // SURVEILLANCE LOCATIONS
                // v8.5 REFINED: Facing interiors for cams 2, 3, 4, and 6.
                this.camData = [
                    { id: 1, name: "CAM 01 - MAIN HALL", pos: new THREE.Vector3(-0.04, 2.31, -6.39), look: new THREE.Vector3(0, 1.5, -18) },
                    { id: 2, name: "CAM 02 - DINING AREA", pos: new THREE.Vector3(-3.61, 2.46, 1), look: new THREE.Vector3(-2, 1.2, -15) }, 
                    { id: 3, name: "CAM 03 - PARTY ROOM", pos: new THREE.Vector3(3.79, 2.64, 1), look: new THREE.Vector3(2, 1.2, -15) },  
                    { id: 4, name: "CAM 04 - SUPPLY CLOSET", pos: new THREE.Vector3(-4.06, 2.54, -5.65), look: new THREE.Vector3(-8.0, 0.8, -1.0) }, 
                    { id: 5, name: "CAM 05 - PIRATE COVE", pos: new THREE.Vector3(-9.99, 2.28, -11.72), look: new THREE.Vector3(-10, 1.5, -25) },
                    { id: 6, name: "CAM 06 - KITCHEN HALL", pos: new THREE.Vector3(-6.36, 2.35, -22.88), look: new THREE.Vector3(5, 1.5, -10) }
                ];
                this.activeCamId = -1;

                // ANIMATRONICS CONFIG
                // Balanced movement speed for a tense experience.
                this.animatronics = [
                    { name: 'Devil', texture: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQevmPBcXlRBwNwZS5Yd5fQEx2lwQZm4VaznQ&s', spawn: new THREE.Vector3(0.13, 0.40, -19.20), state: 'WAKEUP', mesh: null, lightTimer: 0, target: null, side: 'center', wakeTimer: 8.0, waitTimer: 0, stalkLevel: 0, speed: 0.52 },
                    { name: 'Freak', texture: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSv-Y-8unCnufjKBV5qT7QL_VxyGST0PPRYfw&s', spawn: new THREE.Vector3(2.64, 0.28, -17.91), state: 'WAKEUP', mesh: null, lightTimer: 0, target: null, side: 'right', wakeTimer: 18.0, waitTimer: 0, stalkLevel: 0, speed: 0.46 },
                    { name: 'Absolute', texture: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRcaDc6IF51Cwx-1rYJ0XCu8LkpJGmRWZwyPA&s', spawn: new THREE.Vector3(-2.62, 0.30, -17.80), state: 'WAKEUP', mesh: null, lightTimer: 0, target: null, side: 'left', wakeTimer: 28.0, waitTimer: 0, stalkLevel: 0, speed: 0.38 }
                ];

                // NAVIGATION NODES
                this.roamNodes = [
                    new THREE.Vector3(0, 0.4, -10), new THREE.Vector3(-6, 0.4, -12),
                    new THREE.Vector3(6, 0.4, -12), new THREE.Vector3(-10, 0.4, -15),
                    new THREE.Vector3(10, 0.4, -15), new THREE.Vector3(-4, 0.4, -5),
                    new THREE.Vector3(4, 0.4, -5), new THREE.Vector3(0, 0.4, -18),
                    new THREE.Vector3(-2, 0.4, -3), new THREE.Vector3(2, 0.4, -3),
                    new THREE.Vector3(-8, 0.4, -18), new THREE.Vector3(8, 0.4, -18)
                ];

                this.hallwayNodes = {
                    left: [new THREE.Vector3(-8.0, 0.4, -8.0), new THREE.Vector3(-4.0, 0.4, -4.0), new THREE.Vector3(-2.2, 0.4, 1.2)],
                    right: [new THREE.Vector3(8.0, 0.4, -8.0), new THREE.Vector3(4.0, 0.4, -4.0), new THREE.Vector3(2.2, 0.4, 1.2)],
                    center: [new THREE.Vector3(0.0, 0.4, -10.0), new THREE.Vector3(1.5, 0.4, -4.0), new THREE.Vector3(2.2, 0.4, 1.2)]
                };

                // Interactive Objects
                this.doors = {
                    left: { closed: false, pos: new THREE.Vector3(-1.56, 1.41, 0.51), mesh: null },
                    right: { closed: false, pos: new THREE.Vector3(1.57, 1.65, 0.74), mesh: null }
                };

                // Door collision removal logic for decorative elements
                this.phaseableDoorPositions = [
                    new THREE.Vector3(-1.56, 1.41, 0.51), new THREE.Vector3(1.57, 1.65, 0.74),
                    new THREE.Vector3(2.63, 1.00, -6.03), new THREE.Vector3(-2.88, 1.14, -6.04),
                    new THREE.Vector3(-3.92, 1.37, -3.93), new THREE.Vector3(-3.51, 1.92, -19.41),
                    new THREE.Vector3(-9.93, 1.65, -15.04)
                ];

                // Physics Engine Configuration
                this.worldOctree = new Octree();
                this.playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1.45, 0), 0.35);
                this.playerVelocity = new THREE.Vector3();
                this.playerDirection = new THREE.Vector3();
                this.playerOnGround = false;

                // Player Movement Settings
                this.bobTimer = 0;
                this.tiltAmount = 0;
                this.maxSpeed = 1.35;
                this.friction = 35.0;
                this.accel = 100.0;

                // Interaction Matrix
                this.interactionData = [
                    { pos: [-1.48, 1.36, 1.62], name: 'LEFT DOOR', action: 'toggleLeftDoor', radius: 0.14 },
                    { pos: [-1.41, 1.09, 1.66], name: 'LEFT LIGHT', action: 'toggleLeftLight', radius: 0.14 },
                    { pos: [1.40, 1.32, 1.64], name: 'RIGHT DOOR', action: 'toggleRightDoor', radius: 0.14 },
                    { pos: [1.40, 1.12, 1.64], name: 'RIGHT LIGHT', action: 'toggleRightLight', radius: 0.14 },
                    { pos: [1.08, 1.13, -0.47], name: 'CAM FEED 1', action: 'cam', camId: 1, radius: 0.22 },
                    { pos: [0.83, 1.56, -0.59], name: 'CAM FEED 2', action: 'cam', camId: 2, radius: 0.22 },
                    { pos: [0.59, 1.12, -0.69], name: 'CAM FEED 3', action: 'cam', camId: 3, radius: 0.22 },
                    { pos: [-0.47, 1.51, -0.60], name: 'CAM FEED 4', action: 'cam', camId: 4, radius: 0.22 },
                    { pos: [-0.56, 1.11, -0.59], name: 'CAM FEED 5', action: 'cam', camId: 5, radius: 0.22 },
                    { pos: [-1.13, 1.31, -0.49], name: 'CAM FEED 6', action: 'cam', camId: 6, radius: 0.22 }
                ];
                this.interactables = [];

                // Lighting Components
                this.officeLight = new THREE.PointLight(0xffffff, 2.0, 10);
                this.officeLight.position.set(0, 2.5, 1);
                this.officeLight.castShadow = true;
                this.scene.add(this.officeLight);
                
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.08);
                this.scene.add(this.ambientLight);

                this.raycaster = new THREE.Raycaster();
                this.raycaster.far = 2.8;

                this.clock = new THREE.Clock();
                this.initSystems();
                this.loadMap();
                this.loadFlashlight();
                this.initAnimatronics();
                this.createHotspots();
                this.initEvents();
                this.animate();
            }

            /**
             * Initialize static scene components like office doors and hallway lights.
             */
            initSystems() {
                const doorGeo = new THREE.BoxGeometry(0.1, 4, 1.8);
                const doorMat = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.0, depthWrite: false });
                
                this.doors.left.mesh = new THREE.Mesh(doorGeo, doorMat);
                this.doors.left.mesh.position.copy(this.doors.left.pos);
                this.scene.add(this.doors.left.mesh);
                
                this.doors.right.mesh = new THREE.Mesh(doorGeo, doorMat);
                this.doors.right.mesh.position.copy(this.doors.right.pos);
                this.scene.add(this.doors.right.mesh);

                this.hallwayLights = {
                    left: { on: false, light: new THREE.PointLight(0xffffff, 0, 8), pos: new THREE.Vector3(-2.2, 1.8, 1.2) },
                    right: { on: false, light: new THREE.PointLight(0xffffff, 0, 8), pos: new THREE.Vector3(2.2, 1.8, 1.2) }
                };
                
                this.scene.add(this.hallwayLights.left.light);
                this.hallwayLights.left.light.position.copy(this.hallwayLights.left.pos);
                this.scene.add(this.hallwayLights.right.light);
                this.hallwayLights.right.light.position.copy(this.hallwayLights.right.pos);
               
                this.flashlightBeam = new THREE.SpotLight(0xffffff, 0, 25, Math.PI * 0.12, 0.4, 1);
                this.scene.add(this.flashlightBeam);
                this.flashlightBeam.target = new THREE.Object3D();
                this.scene.add(this.flashlightBeam.target);
            }

            /**
             * Setup animatronic entities with billboard planes and physical capsules.
             */
            initAnimatronics() {
                const loader = new THREE.TextureLoader();
                this.animatronics.forEach(cfg => {
                    const texture = loader.load(cfg.texture);
                    const mat = new THREE.MeshStandardMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        alphaTest: 0.5,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const plane = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 2.1), mat);
                    plane.position.copy(cfg.spawn).add(new THREE.Vector3(0, 1.05, 0));
                    plane.castShadow = true;
                    plane.receiveShadow = true;
                    this.scene.add(plane);
                    
                    cfg.mesh = plane;
                    cfg.collider = new Capsule(cfg.spawn.clone().add(new THREE.Vector3(0,0.35,0)), cfg.spawn.clone().add(new THREE.Vector3(0,1.45,0)), 0.5);
                    cfg.target = cfg.spawn.clone();
                    cfg.targetNodeIdx = -1;
                });
            }

            /**
             * Instantiate collision-detectable spheres for raycasting interactions.
             */
            createHotspots() {
                this.interactionData.forEach(data => {
                    const geo = new THREE.SphereGeometry(data.radius || 0.15, 12, 12);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.0, depthWrite: false });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(...data.pos);
                    mesh.userData = { ...data };
                    this.scene.add(mesh);
                    this.interactables.push(mesh);
                });
            }

            /**
             * Load the flashlight collectible model from the external CDN.
             */
            loadFlashlight() {
                const loader = new GLTFLoader();
                loader.load('https://cdn.jsdelivr.net/gh/abminn/Nexus-Games@main/Games/Five%20Nights%20At%20Abmins/flashlight.glb', (gltf) => {
                    const scene = gltf.scene || gltf.scenes[0];
                    if (!scene) return;
                    this.flashlightWorldModel = scene;
                    this.flashlightWorldModel.position.set(0.06, 1.05, -0.39);
                    this.flashlightWorldModel.scale.set(0.1, 0.1, 0.1);
                    this.flashlightWorldModel.rotation.set(0, Math.PI, 0);
                    this.scene.add(this.flashlightWorldModel);
                });
            }

            /**
             * Load the main restaurant map and construct the Octree for world collisions.
             */
            loadMap() {
                const loader = new GLTFLoader();
                const url = 'https://cdn.jsdelivr.net/gh/abminn/Nexus-Games@main/Games/Five%20Nights%20At%20Abmins/fnaf_1_map-compressed.glb';
                const bar = document.getElementById('loading-bar');
                const statusText = document.getElementById('status-text');
                const subtext = document.getElementById('loading-subtext');
               
                loader.load(url, (gltf) => {
                    const scene = gltf.scene || gltf.scenes[0];
                    if (!scene) return;
                    this.scene.add(scene);
                    subtext.innerText = "Applying Physical Filters...";
                   
                    setTimeout(() => {
                        const collisionGroup = new THREE.Group();
                        const box = new THREE.Box3();
                        const center = new THREE.Vector3();
                        scene.updateMatrixWorld(true);
                        
                        scene.traverse((n) => {
                            if (n.isMesh) {
                                n.castShadow = true;
                                n.receiveShadow = true;
                                const name = n.name.toLowerCase();
                                n.geometry.computeBoundingBox();
                                box.copy(n.geometry.boundingBox).applyMatrix4(n.matrixWorld);
                                box.getCenter(center);
                                
                                // Selective collision removal for decorative doors
                                let isDoor = name.includes('door') || name.includes('locked');
                                let nearPhaseable = false;
                                for (const pos of this.phaseableDoorPositions) {
                                    if (center.distanceTo(pos) < 2.0) {
                                        nearPhaseable = true;
                                        break;
                                    }
                                }

                                if (!isDoor && !nearPhaseable) {
                                    collisionGroup.add(n.clone());
                                }
                            }
                        });

                        this.worldOctree.fromGraphNode(collisionGroup);
                        this.playerCollider.start.set(0, 0.35, 0);
                        this.playerCollider.end.set(0, 1.45, 0);
                       
                        this.isLoaded = true;
                        statusText.innerHTML = '<h1 class="text-2xl font-black mb-1">CONNECTED</h1><p class="text-[10px] text-green-500 font-bold uppercase tracking-[0.3em]">Network Active</p><p class="text-[10px] mt-6 text-gray-500">CLICK TO COMMENCE SHIFT</p>';
                        bar.style.width = '100%';
                    }, 100);

                }, (xhr) => {
                    if (xhr.total > 0) bar.style.width = (xhr.loaded / xhr.total * 100) + '%';
                    else bar.style.width = '80%';
                });
            }

            /**
             * Reset the entire engine state to 12 AM values.
             */
            resetGame() {
                document.getElementById('jumpscare').style.display = 'none';
                document.getElementById('power-outage').style.display = 'none';
                this.exitCamera();
                this.battery = 100.0;
                this.isPowerOut = false;
                this.isGameOver = false;
                this.playerVelocity.set(0, 0, 0);
                this.playerCollider.start.set(0, 0.35, 0);
                this.playerCollider.end.set(0, 1.45, 0);
                this.moveState.yaw = 0;
                this.moveState.pitch = 0;
                this.camera.position.copy(this.playerCollider.end);
                this.doors.left.closed = false;
                this.doors.left.mesh.material.opacity = 0;
                this.doors.right.closed = false;
                this.doors.right.mesh.material.opacity = 0;
                this.hallwayLights.left.on = false;
                this.hallwayLights.left.light.intensity = 0;
                this.hallwayLights.right.on = false;
                this.hallwayLights.right.light.intensity = 0;
                this.officeLight.intensity = 2.0;
                this.ambientLight.intensity = 0.08;
                
                this.animatronics.forEach((anim, i) => {
                    anim.state = 'WAKEUP';
                    anim.wakeTimer = 8.0 + (i * 10.0);
                    anim.waitTimer = 0;
                    anim.lightTimer = 0;
                    anim.stalkLevel = 0;
                    anim.target = anim.spawn.clone();
                    anim.collider.start.copy(anim.spawn).add(new THREE.Vector3(0, 0.35, 0));
                    anim.collider.end.copy(anim.spawn).add(new THREE.Vector3(0, 1.45, 0));
                    anim.mesh.position.copy(anim.collider.end).add(new THREE.Vector3(0, -0.4, 0));
                });
                document.body.requestPointerLock();
            }

            /**
             * Activate camera mode, applying visual filters and boosting visibility.
             */
            enterCamera(camId) {
                if (this.isPowerOut || this.isGameOver) return;
                const cam = this.camData.find(c => c.id === camId);
                if (!cam) return;
                
                this.inCams = true;
                this.activeCamId = camId;
                
                // UI Updates
                document.getElementById('camera-ui').style.display = 'block';
                document.querySelector('#camera-label span').innerText = cam.name;
                document.getElementById('hud').style.display = 'none';
                document.exitPointerLock();
                
                // View Updates
                this.camera.position.copy(cam.pos);
                this.camera.lookAt(cam.look);
                
                // LIGHTING BOOST: Enhanced visibility in surveillance mode
                this.ambientLight.intensity = 0.35;
                
                this.showInteractFeedback(`SECURE FEED: ${cam.name}`, null);
            }

            /**
             * Deactivate camera mode and return to first person view.
             */
            exitCamera() {
                this.inCams = false;
                this.activeCamId = -1;
                document.getElementById('camera-ui').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                this.camera.position.copy(this.playerCollider.end);
                
                // Restore standard lighting
                this.ambientLight.intensity = 0.08;
                
                document.body.requestPointerLock();
            }

            /**
             * Input and Event Listeners registration.
             */
            initEvents() {
                const overlay = document.getElementById('overlay');
                overlay.addEventListener('click', () => { 
                    if (!this.isPowerOut && this.isLoaded && !this.isGameOver && !this.inCams) 
                        document.body.requestPointerLock(); 
                });
                
                document.getElementById('reset-jumpscare-btn').onclick = () => this.resetGame();
                document.getElementById('reset-outage-btn').onclick = () => this.resetGame();
                document.getElementById('exit-cams-btn').onclick = () => this.exitCamera();

                document.addEventListener('mousedown', () => {
                    if (this.inCams) return;
                    if (document.pointerLockElement !== document.body || this.isPowerOut || !this.isLoaded || this.isGameOver) return;
                    
                    this.raycaster.setFromCamera({ x: 0, y: 0 }, this.camera);
                    const hits = this.raycaster.intersectObjects(this.interactables);
                    
                    if (hits.length > 0) {
                        const target = hits[0].object;
                        const action = target.userData.action;
                        let msg = target.userData.name;
                        
                        if (action === 'toggleLeftDoor') { 
                            this.doors.left.closed = !this.doors.left.closed; 
                            this.doors.left.mesh.material.opacity = this.doors.left.closed ? 0.3 : 0.0; 
                            msg += this.doors.left.closed ? ' : SHUT' : ' : OPEN'; 
                        }
                        if (action === 'toggleRightDoor') { 
                            this.doors.right.closed = !this.doors.right.closed; 
                            this.doors.right.mesh.material.opacity = this.doors.right.closed ? 0.3 : 0.0; 
                            msg += this.doors.right.closed ? ' : SHUT' : ' : OPEN'; 
                        }
                        if (action === 'toggleLeftLight') { 
                            this.hallwayLights.left.on = !this.hallwayLights.left.on; 
                            this.hallwayLights.left.light.intensity = this.hallwayLights.left.on ? 12.0 : 0.0; 
                            msg += this.hallwayLights.left.on ? ' : ACTIVE' : ' : INACTIVE'; 
                        }
                        if (action === 'toggleRightLight') { 
                            this.hallwayLights.right.on = !this.hallwayLights.right.on; 
                            this.hallwayLights.right.light.intensity = this.hallwayLights.right.on ? 12.0 : 0.0; 
                            msg += this.hallwayLights.right.on ? ' : ACTIVE' : ' : INACTIVE'; 
                        }
                        if (action === 'cam') { 
                            this.enterCamera(target.userData.camId); 
                            return; 
                        }
                        this.showInteractFeedback(msg, target);
                    }

                    // Item collection check
                    if (!this.hasFlashlight && this.flashlightWorldModel) {
                        if (this.camera.position.distanceTo(this.flashlightWorldModel.position) < 2.8) {
                            this.hasFlashlight = true;
                            this.scene.remove(this.flashlightWorldModel);
                            this.flashlightWorldModel = null;
                            this.showInteractFeedback("FLASHLIGHT COLLECTED", null);
                            this.updateHotbarVisuals();
                        }
                    }
                });

                document.getElementById('copy-pos').onclick = (e) => { 
                    e.stopPropagation(); 
                    navigator.clipboard.writeText(`POS: ${this.camera.position.x.toFixed(2)}, ${this.camera.position.y.toFixed(2)}, ${this.camera.position.z.toFixed(2)}`); 
                };
                
                document.addEventListener('pointerlockchange', () => { 
                    if (!this.inCams) overlay.style.display = document.pointerLockElement === document.body ? 'none' : 'block'; 
                });
                
                const moveMap = { KeyW: 'forward', KeyS: 'backward', KeyA: 'left', KeyD: 'right' };
                this.moveState = { forward: false, backward: false, left: false, right: false, yaw: 0, pitch: 0 };
                
                window.onkeydown = (e) => {
                    if (this.inCams) {
                        if (e.code === 'KeyX' || e.code === 'Escape') this.exitCamera();
                        return;
                    }
                    if (moveMap[e.code]) this.moveState[moveMap[e.code]] = true;
                    const key = parseInt(e.key); 
                    if (key >= 1 && key <= 5) this.setHotbarSlot(key - 1);
                    if (e.code === 'KeyF') this.toggleFlashlight();
                };
                
                window.onkeyup = (e) => { if (moveMap[e.code]) this.moveState[moveMap[e.code]] = false; };
                
                document.onmousemove = (e) => {
                    if (this.inCams || document.pointerLockElement !== document.body || this.isPowerOut || !this.isLoaded || this.isGameOver) return;
                    this.moveState.yaw -= e.movementX * 0.0012; 
                    this.moveState.pitch -= e.movementY * 0.0012;
                    this.moveState.pitch = Math.max(-1.5, Math.min(1.5, this.moveState.pitch));
                };
            }

            toggleFlashlight() { 
                if (this.hasFlashlight && !this.isPowerOut) { 
                    this.flashlightActive = !this.flashlightActive; 
                    this.flashlightBeam.intensity = this.flashlightActive ? 25 : 0; 
                } 
            }
            
            updateHotbarVisuals() { if (this.hasFlashlight) document.querySelectorAll('.hotbar-slot')[0].innerHTML = '<span class="item-label">FLASH</span>'; }
            
            showInteractFeedback(msg, target) {
                const im = document.getElementById('interaction-msg'); 
                im.innerText = msg; 
                im.style.opacity = '1'; 
                im.style.bottom = '130px';
                if (target) { target.material.opacity = 0.8; target.scale.set(1.4, 1.4, 1.4); }
                setTimeout(() => { 
                    im.style.opacity = '0'; 
                    im.style.bottom = '120px'; 
                    if (target) { target.material.opacity = 0.0; target.scale.set(1, 1, 1); } 
                }, 200);
            }
            
            setHotbarSlot(index) { 
                this.activeSlot = index; 
                document.querySelectorAll('.hotbar-slot').forEach((s, idx) => { 
                    if (idx === index) s.classList.add('selected'); 
                    else s.classList.remove('selected'); 
                }); 
            }

            /**
             * Process AI behavior for animatronics including pathfinding and attacking.
             */
            updateAnimatronics(delta) {
                if (!this.isLoaded || this.isPowerOut || this.isGameOver) return;

                this.animatronics.forEach(anim => {
                    // Update billboard rotation to face observer
                    const lookPoint = this.inCams ? this.camera.position : this.camera.position;
                    anim.mesh.lookAt(lookPoint.x, anim.mesh.position.y, lookPoint.z);
                    const distToPlayer = anim.mesh.position.distanceTo(this.playerCollider.end);

                    if (anim.waitTimer > 0) { anim.waitTimer -= delta; return; }

                    if (anim.state === 'WAKEUP') {
                        anim.wakeTimer -= delta;
                        const res = this.worldOctree.capsuleIntersect(anim.collider);
                        if (res) anim.collider.translate(res.normal.multiplyScalar(res.depth));
                        if (anim.wakeTimer <= 0) anim.state = 'ROAM';
                        return;
                    }

                    // Lighting detection logic
                    const inHallwayLight = (anim.side === 'left' && this.hallwayLights.left.on && anim.mesh.position.distanceTo(this.hallwayLights.left.pos) < 5.0) ||
                                           (anim.side === 'right' && this.hallwayLights.right.on && anim.mesh.position.distanceTo(this.hallwayLights.right.pos) < 5.0);
                    let inFlashlight = false;
                    if (this.flashlightActive) {
                        const dirToAnim = anim.mesh.position.clone().sub(this.playerCollider.end).normalize();
                        const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(this.camera.quaternion);
                        if (camDir.angleTo(dirToAnim) < 0.3 && distToPlayer < 10.0) inFlashlight = true;
                    }

                    if (inHallwayLight || inFlashlight) {
                        anim.lightTimer += delta;
                        if (anim.lightTimer > 0.3) {
                            const retreatDir = anim.mesh.position.clone().sub(this.playerCollider.end).setY(0).normalize();
                            anim.collider.translate(retreatDir.multiplyScalar(2.0 * delta));
                            if (anim.lightTimer > 2.0) {
                                anim.state = 'RETREAT';
                                const hallwayStart = this.hallwayNodes[anim.side][1] || this.roamNodes[0];
                                anim.target = hallwayStart.clone();
                                anim.stalkLevel = Math.max(0, anim.stalkLevel - 0.2);
                            }
                        }
                    } else { anim.lightTimer = Math.max(0, anim.lightTimer - delta); }

                    // Movement speed logic
                    let speed = anim.speed;
                    if (anim.state === 'RETREAT') {
                        speed = 3.0;
                        if (anim.mesh.position.distanceTo(anim.target) < 1.0) {
                            anim.state = 'ROAM';
                            anim.lightTimer = 0;
                            anim.waitTimer = 3.0;
                        }
                    } else {
                        // Region-based wandering AI
                        if (anim.mesh.position.distanceTo(anim.target) < 1.8 || anim.targetNodeIdx === -1) {
                            anim.waitTimer = 2.0 + Math.random() * 4.0; 
                           
                            if (Math.random() < (0.2 + anim.stalkLevel * 0.1)) {
                                const path = this.hallwayNodes[anim.side] || this.hallwayNodes.center;
                                anim.targetNodeIdx = Math.min(anim.targetNodeIdx + 1, path.length - 1);
                                anim.target = path[anim.targetNodeIdx].clone();
                                anim.stalkLevel += 0.03;
                            } else {
                                if (Math.random() < 0.4) {
                                    const camLoc = this.camData[Math.floor(Math.random() * this.camData.length)].pos;
                                    anim.target = camLoc.clone().setY(0.4);
                                } else {
                                    const randomNode = this.roamNodes[Math.floor(Math.random() * this.roamNodes.length)];
                                    anim.target = randomNode.clone();
                                }
                            }
                            anim.target.x += (Math.random() - 0.5) * 3.0;
                            anim.target.z += (Math.random() - 0.5) * 3.0;
                        }

                        // Aggression range check
                        const dx = Math.abs(anim.mesh.position.x - this.playerCollider.end.x);
                        const dz = Math.abs(anim.mesh.position.z - this.playerCollider.end.z);
                        if (dx < 3.0 && dz < 3.0 && !this.isBlocked(anim, distToPlayer)) {
                            speed = 2.2; 
                            anim.target.copy(this.playerCollider.end).setY(anim.mesh.position.y);
                        }
                    }

                    // Physics update for animatronic
                    const subSteps = 2;
                    const subDelta = delta / subSteps;
                    const moveDir = anim.target.clone().sub(anim.mesh.position).setY(0).normalize();
                    for (let s = 0; s < subSteps; s++) {
                        anim.collider.translate(moveDir.clone().multiplyScalar(speed * subDelta));
                        for (let i = 0; i < 4; i++) {
                            const result = this.worldOctree.capsuleIntersect(anim.collider);
                            if (result) anim.collider.translate(result.normal.multiplyScalar(result.depth * 0.95 + 0.0001));
                        }
                    }
                    anim.collider.translate(new THREE.Vector3(0, -9.8 * delta, 0));
                    const floorResult = this.worldOctree.capsuleIntersect(anim.collider);
                    if (floorResult) anim.collider.translate(floorResult.normal.multiplyScalar(floorResult.depth * 0.95));
                    anim.mesh.position.copy(anim.collider.end).add(new THREE.Vector3(0, -0.4, 0));

                    // Detection / Kill check
                    if (distToPlayer < 1.45) {
                        const isProtected = (anim.mesh.position.x < -0.5 && this.doors.left.closed) || (anim.mesh.position.x > 0.5 && this.doors.right.closed);
                        if (!isProtected) {
                            this.triggerGameOver();
                        } else {
                            const pushBackDir = anim.mesh.position.clone().sub(this.playerCollider.end).setY(0).normalize();
                            anim.collider.translate(pushBackDir.multiplyScalar(1.5));
                            anim.state = 'RETREAT';
                            const stalkPoint = this.hallwayNodes[anim.side][1] || this.roamNodes[0];
                            anim.target = stalkPoint.clone();
                            anim.targetNodeIdx = -1;
                            anim.waitTimer = 1.0;
                        }
                    }
                });
            }

            isBlocked(anim, dist) {
                if (anim.mesh.position.x < -0.5 && this.doors.left.closed && dist < 4.0) return true;
                if (anim.mesh.position.x > 0.5 && this.doors.right.closed && dist < 4.0) return true;
                return false;
            }

            triggerGameOver() {
                this.isGameOver = true;
                this.exitCamera();
                document.getElementById('jumpscare').style.display = 'flex';
                document.exitPointerLock();
            }

            /**
             * Resolve player character vs world and office door collisions.
             */
            playerCollisions() {
                this.playerOnGround = false;
                for (let i = 0; i < 4; i++) {
                    const result = this.worldOctree.capsuleIntersect(this.playerCollider);
                    if (result) {
                        this.playerOnGround = this.playerOnGround || result.normal.y > 0.5;
                        const projection = this.playerVelocity.dot(result.normal);
                        if (projection < 0) this.playerVelocity.addScaledVector(result.normal, -projection);
                        this.playerCollider.translate(result.normal.multiplyScalar(result.depth * 0.95 + 0.0001));
                    }
                }
                
                const doorBox = new THREE.Box3();
                [this.doors.left, this.doors.right].forEach(door => {
                    if (door.closed) {
                        doorBox.setFromObject(door.mesh);
                        const intersect = doorBox.intersectsSphere({ center: this.playerCollider.start, radius: 0.35 }) || doorBox.intersectsSphere({ center: this.playerCollider.end, radius: 0.35 });
                        if (intersect) {
                            const pushDir = this.playerCollider.start.clone().sub(door.pos).setY(0).normalize();
                            this.playerCollider.translate(pushDir.multiplyScalar(0.01));
                            const velDot = this.playerVelocity.dot(pushDir);
                            if (velDot < 0) this.playerVelocity.addScaledVector(pushDir, -velDot * 0.75);
                        }
                    }
                });
            }

            /**
             * Calculate and update global power consumption levels.
             */
            updateBattery(delta) {
                if (this.isPowerOut || !this.isLoaded || this.isGameOver) return;
                
                let activeSystems = (this.doors.left.closed ? 1 : 0) + (this.doors.right.closed ? 1 : 0) + 
                                    (this.hallwayLights.left.on ? 1 : 0) + (this.hallwayLights.right.on ? 1 : 0);
                const flashlightDrain = this.flashlightActive ? 0.2 : 0;
                
                if (this.inCams) {
                    this.camBatteryTimer += delta;
                    if (this.camBatteryTimer >= 8.0) {
                        this.battery -= 1.0;
                        this.camBatteryTimer = 0;
                    }
                } else { this.camBatteryTimer = 0; }

                this.battery -= (0.05 + activeSystems * 0.8 + flashlightDrain) * delta;
                if (this.battery <= 0) { this.battery = 0; this.triggerOutage(); }
                
                document.getElementById('battery-pct').innerText = Math.ceil(this.battery) + '%';
                const bars = document.getElementById('usage-bars').getElementsByClassName('usage-bar');
                const displayUsage = Math.min(5, activeSystems + (this.flashlightActive ? 1 : 0) + (this.inCams ? 1 : 0));
                for (let i = 0; i < bars.length; i++) { if (i < displayUsage) bars[i].classList.add('active'); else bars[i].classList.remove('active'); }
            }

            triggerOutage() {
                this.isPowerOut = true; 
                this.exitCamera();
                this.flashlightActive = false; 
                this.flashlightBeam.intensity = 0;
                this.doors.left.closed = this.doors.right.closed = this.hallwayLights.left.on = this.hallwayLights.right.on = false;
                this.doors.left.mesh.material.opacity = this.doors.right.mesh.material.opacity = 0;
                this.hallwayLights.left.light.intensity = this.hallwayLights.right.light.intensity = this.officeLight.intensity = 0;
                this.ambientLight.intensity = 0;
                document.getElementById('power-outage').style.display = 'flex'; 
                document.exitPointerLock();
            }

            updatePlayer(delta) {
                if (!this.isLoaded || this.isGameOver || this.inCams) return;
                
                if (this.playerOnGround) { 
                    this.playerVelocity.x -= this.playerVelocity.x * this.friction * delta; 
                    this.playerVelocity.z -= this.playerVelocity.z * this.friction * delta; 
                } else {
                    this.playerVelocity.y -= 35.0 * delta;
                }
                
                const horiz = new THREE.Vector2(this.playerVelocity.x, this.playerVelocity.z);
                if (horiz.length() > this.maxSpeed) { 
                    horiz.setLength(this.maxSpeed); 
                    this.playerVelocity.x = horiz.x; 
                    this.playerVelocity.z = horiz.y; 
                }
                
                this.playerCollider.translate(this.playerVelocity.clone().multiplyScalar(delta)); 
                this.playerCollisions();
                
                const moving = (this.moveState.forward || this.moveState.backward || this.moveState.left || this.moveState.right) && this.playerOnGround;
                if (moving) {
                    this.bobTimer += delta * 7.0; 
                    this.camera.position.copy(this.playerCollider.end);
                    this.camera.position.y += Math.sin(this.bobTimer) * 0.032; 
                    this.camera.position.x += Math.cos(this.bobTimer * 0.5) * 0.012;
                    let targetTilt = this.moveState.left ? 0.01 : (this.moveState.right ? -0.01 : 0);
                    this.tiltAmount = THREE.MathUtils.lerp(this.tiltAmount, targetTilt, 0.1);
                } else { 
                    this.camera.position.lerp(this.playerCollider.end, 0.1); 
                    this.tiltAmount = THREE.MathUtils.lerp(this.tiltAmount, 0, 0.1); 
                }
                
                this.camera.rotation.set(this.moveState.pitch, this.moveState.yaw, this.tiltAmount);
                if (this.flashlightBeam) { 
                    this.flashlightBeam.position.copy(this.camera.position); 
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(this.camera.quaternion); 
                    this.flashlightBeam.target.position.copy(this.camera.position).add(dir); 
                }
            }

            getForwardVector() { 
                this.camera.getWorldDirection(this.playerDirection); 
                this.playerDirection.y = 0; 
                this.playerDirection.normalize(); 
                return this.playerDirection; 
            }
            
            getSideVector() { 
                this.camera.getWorldDirection(this.playerDirection); 
                this.playerDirection.y = 0; 
                this.playerDirection.normalize(); 
                this.playerDirection.cross(this.camera.up); 
                return this.playerDirection; 
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = Math.min(0.03, this.clock.getDelta());
                
                if (document.pointerLockElement === document.body && !this.isPowerOut && this.isLoaded && !this.isGameOver && !this.inCams) {
                    const speed = this.playerOnGround ? this.accel : 30;
                    if (this.moveState.forward) this.playerVelocity.add(this.getForwardVector().multiplyScalar(speed * delta));
                    if (this.moveState.backward) this.playerVelocity.add(this.getForwardVector().multiplyScalar(-speed * delta));
                    if (this.moveState.left) this.playerVelocity.add(this.getSideVector().multiplyScalar(-speed * delta));
                    if (this.moveState.right) this.playerVelocity.add(this.getSideVector().multiplyScalar(speed * delta));
                }

                this.updatePlayer(delta);
                this.updateBattery(delta);
                this.updateAnimatronics(delta);
                
                if (!this.inCams) {
                    document.getElementById('pos-display').innerText = `${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)}`;
                } else {
                    document.getElementById('pos-display').innerText = "REMOTE ACCESS ACTIVE";
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize Engine
        new Engine();
    </script>
</body>
</html>